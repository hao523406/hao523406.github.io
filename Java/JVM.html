<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JVM | Hao-Blog</title>
    <meta name="description" content="专注互联网技术">
    
    
    <link rel="preload" href="/assets/css/0.styles.595b60ed.css" as="style"><link rel="preload" href="/assets/js/app.04a292d2.js" as="script"><link rel="preload" href="/assets/js/2.4fad892d.js" as="script"><link rel="preload" href="/assets/js/5.811e20e2.js" as="script"><link rel="prefetch" href="/assets/js/10.8e879de9.js"><link rel="prefetch" href="/assets/js/11.b217e124.js"><link rel="prefetch" href="/assets/js/12.013bff42.js"><link rel="prefetch" href="/assets/js/13.3cdff795.js"><link rel="prefetch" href="/assets/js/14.b5ab60e6.js"><link rel="prefetch" href="/assets/js/15.50bec27e.js"><link rel="prefetch" href="/assets/js/16.c16c9f53.js"><link rel="prefetch" href="/assets/js/3.30ead0c9.js"><link rel="prefetch" href="/assets/js/4.c0014c96.js"><link rel="prefetch" href="/assets/js/6.dba0d004.js"><link rel="prefetch" href="/assets/js/7.35746c6c.js"><link rel="prefetch" href="/assets/js/8.6b384213.js"><link rel="prefetch" href="/assets/js/9.9b657d40.js">
    <link rel="stylesheet" href="/assets/css/0.styles.595b60ed.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Hao-Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>JVM</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Java/JVM.html#jvm体系结构" class="sidebar-link">JVM体系结构</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Java/JVM.html#classloader" class="sidebar-link">ClassLoader</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Java/JVM.html#jvm的classloader" class="sidebar-link">JVM的ClassLoader</a></li><li class="sidebar-sub-header"><a href="/Java/JVM.html#classloader的加载原理" class="sidebar-link">ClassLoader的加载原理</a></li></ul></li><li><a href="/Java/JVM.html#execution-engine" class="sidebar-link">Execution Engine</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Java/JVM.html#native" class="sidebar-link">Native</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Java/JVM.html#pc寄存器" class="sidebar-link">PC寄存器</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Java/JVM.html#方法区" class="sidebar-link">方法区</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Java/JVM.html#栈" class="sidebar-link">栈</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Java/JVM.html#堆" class="sidebar-link">堆</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Java/JVM.html#堆的组成" class="sidebar-link">堆的组成</a></li><li class="sidebar-sub-header"><a href="/Java/JVM.html#堆内存调优" class="sidebar-link">堆内存调优</a></li></ul></li><li><a href="/Java/JVM.html#gc" class="sidebar-link">GC</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Java/JVM.html#gc-4大算法" class="sidebar-link">GC 4大算法</a></li></ul></li><li><a href="/Java/JVM.html#jmm" class="sidebar-link">JMM</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Java/JVM.html#面试" class="sidebar-link">面试</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="jvm"><a href="#jvm" class="header-anchor">#</a> JVM</h1> <h2 id="jvm体系结构"><a href="#jvm体系结构" class="header-anchor">#</a> JVM体系结构</h2> <ul><li>JVM是运行在操作系统之上的，它与硬件没有直接的交互。</li></ul> <p><img src="https://good-person.gitee.io/blog-bed/e0d05571783e41488082f42b70854b88.png" alt=""></p> <ul><li>三种JVM：
<ul><li>Sun公司的<strong>HotSpot</strong></li> <li>BEA公司的JRockit</li> <li>IBM公司的J9 VM</li></ul></li></ul> <h2 id="classloader"><a href="#classloader" class="header-anchor">#</a> ClassLoader</h2> <ul><li><p><strong>ClassLoader (类装载器)</strong>：负责加载class文件，class文件在文件开头有特定的文件标示，并且ClassLoader<strong>只负责class文件的加载</strong>，至于class是否可以运行，则由 Execution Engine (执行引擎)决定。</p> <p><img src="https://good-person.gitee.io/blog-bed/f637cc361ba84d7686514d07ad068b98.png" alt=""></p></li></ul> <h3 id="jvm的classloader"><a href="#jvm的classloader" class="header-anchor">#</a> JVM的ClassLoader</h3> <ul><li><p>JVM的类加载器：</p> <ul><li><p>虚拟机自带的加载器：</p> <table><thead><tr><th style="text-align:left;">类加载器</th> <th style="text-align:left;">作用</th> <th style="text-align:left;">实现语言</th></tr></thead> <tbody><tr><td style="text-align:left;"><strong>Bootstrap ClassLoader</strong> (启动类加载器)</td> <td style="text-align:left;">加载<code>$JAVA_HOME/jre/lib/rt.jar</code>下的类(class文件)</td> <td style="text-align:left;">C++</td></tr> <tr><td style="text-align:left;"><strong>Extension ClassLoader</strong> (扩展类加载器)</td> <td style="text-align:left;">加载<code>$JAVA_HOME/jre/lib/ext/*.jar</code>下的类(class文件)</td> <td style="text-align:left;">Java</td></tr> <tr><td style="text-align:left;"><strong>Appliation ClassLoader</strong> (系统类加载器/应用程序类加载器)</td> <td style="text-align:left;">加载当前应用的classpath的所有类</td> <td style="text-align:left;">Java</td></tr></tbody></table></li> <li><p>用户自定义加载器：User-Defined Class Loader，<code>java.lang.ClassLoader</code>的字类，用户可以定义类的加载方式。</p> <blockquote><p><code>sun.misc.Launcher</code> 它是一个java虚拟机的入口应用。</p></blockquote></li></ul></li> <li><p>关系图：</p> <p><img src="https://good-person.gitee.io/blog-bed/0d7eec28f6534ad68b8c53f1f10e94e2.png" alt=""></p></li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// null</span>

    <span class="token class-name">Demo</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// null</span>
    <span class="token class-name">Demo</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// sun.misc.Launcher$ExtClassLoader@1b6d3586</span>
    <span class="token class-name">Demo</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span>
<span class="token punctuation">}</span>
<span class="token comment">/*
	null表示最顶层的类加载器即Bootstrap ClassLoader，因为该加载器由C++实现，所以看不到用null表示
	上下对比看出，类加载器的继承关系。而且看出Object等java.lang包的类由Bootstrap ClassLoader加载。
 */</span>
</code></pre></div><h3 id="classloader的加载原理"><a href="#classloader的加载原理" class="header-anchor">#</a> ClassLoader的加载原理</h3> <p>JVM对class文件采用的是<strong>按需加载</strong>的方式，也就是当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，JVM采用的是双亲委派模式(即把加载请求交由父类处理，是一种任务委派模式)。</p> <ul><li><p><strong>双亲委派机制</strong>：如果一个类加载器收到了类加载的请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行。如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终到达最顶层的Bootstrap ClassLoader。如果父类加载器可以完成这个类的加载任务，就成功返回。如果父类加载器无法完成加载任务，子加载器才会尝试自己去加载，这个过程也叫反向委派。只要这个类存在，最后肯定能加载成功进内存。</p> <blockquote><ul><li><p>避免类的重复加载；</p></li> <li><p>保护程序安全，防止核心API被随意更改。</p></li></ul></blockquote></li> <li><p><strong>沙箱安全机制</strong>：保护Java核心代码。</p> <blockquote><p>例如自定义 java.lang.String 类，与Java核心的String类的全限定名相同。由于JVM的双亲委派机制，JVM会优先加载 $JAVA_HOME/jre/lib/rt.jar里的 java.lang.String 类，自定义的String类就不会被加载，保证了Java核心代码的安全，其他类使用Java API不会出现问题。</p> <p>如果在自定义 java.lang.String 类里添加main方法，运行会报错：</p> <div class="language-java extra-class"><pre class="language-java"><code>错误<span class="token operator">:</span> 在类 java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span><span class="token class-name">String</span> 中找不到 main 方法<span class="token punctuation">,</span> 请将 main 方法定义为<span class="token operator">:</span>
   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>
否则 <span class="token class-name">JavaFX</span> 应用程序类必须扩展javafx<span class="token punctuation">.</span>application<span class="token punctuation">.</span><span class="token class-name">Application</span>
</code></pre></div><p>因为自定义的String类没有被加载，加载进JVM的String类(也就是Java原来的String类)根本就没有main这个方法，所以运行报错。</p></blockquote></li></ul> <h2 id="execution-engine"><a href="#execution-engine" class="header-anchor">#</a> Execution Engine</h2> <p><strong>Execution Engine (执行引擎)</strong>：执行引擎负责解释命令，提交操作系统执行。</p> <h2 id="native"><a href="#native" class="header-anchor">#</a> Native</h2> <ul><li><p><strong>Native Interface (本地接口)</strong>：本地接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++程序，Java 诞生的时候是 C/C++横行的时候，要想立足，必须有调用 C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是 Native Method Stack中登记 native方法，在Execution Engine 执行时加载native libraies。</p> <blockquote><p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用 Socket通信，也可以使用Web Service等等。</p></blockquote></li> <li><p><strong>Native Method Stack (本地方法栈)</strong>：它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</p></li></ul> <p><img src="https://good-person.gitee.io/blog-bed/e0d05571783e41488082f42b70854b88.png" alt=""></p> <blockquote><p>举个native方法的例子：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">private</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">start0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>线程对象调用start()方法，该方法里会调用Thread类的start0()方法。该方法是用native修饰，只有方法签名，没有方法实现，都是操作系统需要实现的。所以线程对象调用start()方法，因为内部调用native方法，所以线程不一定马上启动，要根据操作系统决定。</p></blockquote> <h2 id="pc寄存器"><a href="#pc寄存器" class="header-anchor">#</a> PC寄存器</h2> <p><strong>PC寄存器(程序计数器)</strong>：<strong>每个线程</strong>都有一个程序计数器，是<strong>线程私有</strong>的,就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址,也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。</p> <blockquote><p>程序计数器是JVM中唯一一块不会产生error的内存区域。</p></blockquote> <h2 id="方法区"><a href="#方法区" class="header-anchor">#</a> 方法区</h2> <ul><li><strong>方法区</strong>：和 JVM堆一样，是各个线程共享的内存区域，每个JVM只有一个方法区。用于存储已被虚拟机加载的 类信息、常量、静态变量、即时编译器编译后的代码等数据。</li> <li><strong>静态变量 + 常量 + 类/接口的信息 + 方法的信息</strong> 都存在方法区中(所使用的内存都在方法区中分配)，但是实例对象和实例变量存在堆内存中，和方法区无关。</li></ul> <blockquote><p>方法区只是一个规定，相当于Java的接口，JVM另有其他结构实现方法区。</p></blockquote> <ul><li><p><strong>方法区实现</strong>的演变：</p> <table><thead><tr><th style="text-align:left;">时间</th> <th style="text-align:left;">实现</th></tr></thead> <tbody><tr><td style="text-align:left;">JDK7 + 之前</td> <td style="text-align:left;">永久代 (HotSpot JVM的实现)</td></tr> <tr><td style="text-align:left;">JDK8</td> <td style="text-align:left;">元空间 (HotSpot JVM的实现，移除了永久代)</td></tr></tbody></table></li> <li><p><strong>运行时常量池</strong>的演变：</p> <table><thead><tr><th style="text-align:left;">时间</th> <th style="text-align:left;">存放位置</th> <th>实现方式</th></tr></thead> <tbody><tr><td style="text-align:left;">JDK7 + 之前</td> <td style="text-align:left;">方法区</td> <td>永久代</td></tr> <tr><td style="text-align:left;">JDK8</td> <td style="text-align:left;">方法区</td> <td>元空间</td></tr></tbody></table></li> <li><p><strong>字符串常量池</strong>的演变：</p> <table><thead><tr><th style="text-align:left;">时间</th> <th style="text-align:left;">存放位置</th></tr></thead> <tbody><tr><td style="text-align:left;">JDK7 之前</td> <td style="text-align:left;">方法区</td></tr> <tr><td style="text-align:left;">JDK7</td> <td style="text-align:left;">堆</td></tr> <tr><td style="text-align:left;">JDK8</td> <td style="text-align:left;">堆</td></tr></tbody></table></li></ul> <h2 id="栈"><a href="#栈" class="header-anchor">#</a> 栈</h2> <ul><li><p><strong>栈 (Stack)</strong>：也叫 Java虚拟机栈 (Java Virtual Machine Stacks)，是在<strong>线程创建时创建</strong>，是<strong>线程私有</strong>的，它的生命期是跟随线程的生命期，对于栈来说不存在垃圾回收问题，只要线程一结束该栈就Over。</p></li> <li><p>对于 基本数据类型 和 对象类型，<strong>栈存储的数据是：基本数据类型的值(也是对象) 和 对象引用</strong>(存在堆中的对象(普通对象或数组对象)的引用)。</p> <blockquote><p>栈描述Java方法执行的内存模型：每一个方法从调用直到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。每个方法在执行的同时都会创建一个栈帧，压入栈，方法执行完成就会从栈顶弹出，遵循“后进先出”的原则。栈顶的方法就是当前执行的方法。</p></blockquote></li> <li><p><strong>栈帧 (Stack Frame)</strong>：栈帧存储着局部变量表、操作数栈、动态链接、方法出口等信息。</p> <blockquote><p>局部变量表存放了编译期可知的 8种基本数据类型、对象引用、返回地址类型。</p></blockquote> <p><img src="https://good-person.gitee.io/blog-bed/3e183a24246549e6bbc29e50c2c751d4.png" alt=""></p></li> <li><p><strong>栈、堆、方法区的关系：</strong></p></li></ul> <p><img src="https://good-person.gitee.io/blog-bed/1250b63dfbd741fd82f58b4c8d31ed2d.png" alt=""></p> <ul><li><code>java.lang.StackOverflowError</code>：栈溢出。表示某个线程的线程栈空间被耗尽，没有足够资源分配给新创建的栈帧。</li></ul> <h2 id="堆"><a href="#堆" class="header-anchor">#</a> 堆</h2> <ul><li><p><strong>堆 (Heap)</strong>：Java堆是被所有线程共享的一块内存区域，在JVM启动时创建。一个JVM只有一个堆，堆内存的大小是可以调节的，堆是JVM管理的内存中最大的一块。</p></li> <li><p>类加载器读取了类文件后，需要把[ 类、方法、常量(final修饰的变量) ]的对象放到堆内存中，保存所有引用类型的真实信息，以方便执行器执行。</p></li> <li><p><strong>堆只存对象，所有对象都在堆里</strong>：堆不存 基本数据类型的值 和 对象引用，只存对象本身。</p> <blockquote><ul><li>为什么基本数据类型的值(也是对象) 不存到堆中，而是直接在栈中存在这个值？<br>
因为堆中的对象大多数都是动态变化的，就是占用内存的多少是变化的。而栈中存的基本数据类型的值 或 堆中对象的引用都是不变的，长度固定不会出现动态增长。这就是堆栈分离的好处。</li></ul></blockquote></li></ul> <h3 id="堆的组成"><a href="#堆的组成" class="header-anchor">#</a> 堆的组成</h3> <ul><li><p>堆<strong>逻辑</strong>上分为三个部分：</p> <table><thead><tr><th style="text-align:left;"><strong>新生区 (新生代)</strong></th> <th style="text-align:left;"><strong>Young Generation Space</strong></th> <th style="text-align:left;"><strong>Young / New</strong></th></tr></thead> <tbody><tr><td style="text-align:left;"><strong>养老区 (老年代)</strong></td> <td style="text-align:left;"><strong>Tenure generation space</strong></td> <td style="text-align:left;"><strong>Old / Tenure</strong></td></tr> <tr><td style="text-align:left;"><strong>永久区 (永久代)</strong></td> <td style="text-align:left;"><strong>Permanent Space</strong></td> <td style="text-align:left;"><strong>Perm</strong></td></tr></tbody></table> <p><img src="https://good-person.gitee.io/blog-bed/9bda32774f24475397833bc4210bb98c.png" alt=""></p> <ol><li><p>新生区是对象的诞生、成长、消亡的区域，一个对象在这里产生，应用，最后被垃圾回收器收集，结束声明。<strong>新生区</strong>又分为两部分：<strong>伊甸区(Eden Space)、幸存区(Survivor Space)</strong>。<br> <strong>幸存区</strong>有2个区：<strong>幸存 from区、幸存 to区</strong>。from区 和 to区 是相对的。保持**”to区总为空“**的原则。</p></li> <li><p>堆逻辑分区的默认比例：</p> <p><img src="https://good-person.gitee.io/blog-bed/4a529885e72f49168b7ef43eeedb0481.png" alt=""></p></li> <li><p>所有的对象都是在伊甸区被new出来的。<strong>当伊甸区没有足够内存空间分配给新对象时，JVM的垃圾回收器将对 伊甸区 + 幸存from区 进行 Minor GC</strong>：将 伊甸区 + 幸存from区 中的不再被引用的对象进行销毁。如果对象在伊甸区出生并经过第一次 Minor GC 后仍然存活，并且能被幸存区容纳的话，将被移动到幸存区，并且对象年龄设为1。  当它的年龄增加到一定程度(默认15岁)，将被移动到养老区。</p> <blockquote><p>动态年龄判断：JVM并不是永远要求对象年龄达到设置值(默认15岁)才能晋升养老区。如果在幸存区空间中相同年龄所有对象大小的总和大于幸存区空间的一半(指from区)，年龄大于或等于该年龄的对象就可以直接进入养老区，无须等到要求的年龄。</p></blockquote></li> <li><p>发生Minor GC时，检查发现 幸存from区的剩余空间不能满足伊甸区的所有存活对象(就是存活对象不能被幸存区容纳)，只好通过分配担保机制提前将所有存活对象转移到养老区。转移后，幸存区空闲，伊甸区分配足够空间给将要创建的新对象。</p> <blockquote><p>空间分配担保：在发生 Minor GC 之前，JMV会先检查养老区最大可用的连续空间是否大于新生区所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立，则JVM会查看设置值是否允许担保失败。如果允许，那么会继续检查养老区最大可用的连续空间是否大于历次晋升养老区对象的平局大小，如果大于，将尝试着进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者设置值不允许冒险，那么这时也要改为进行一次 Major GC。</p></blockquote></li> <li><p><strong>大对象直接进入养老区</strong>。大对象指需要大量连续内存空间的Java对象，最典型的大对象就是很长的字符串以及数组。</p></li> <li><p><strong>若养老区也满了，就会对养老区进行 Major GC (Full GC)</strong>。若养老区执行了Full GC之后发现以让无法进行对象的保存，就会产生OOM异常&quot;OutOfMemoryError&quot;。</p></li> <li><p><strong>永久区是一个常驻内存区域</strong>，用于存放JDK自身所携带的类、接口的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回到掉的，<strong>关闭 JVM 才会释放此区域的内存</strong>。</p></li></ol> <blockquote><ul><li><p>对象主要分配在新生代的伊甸区上(若启动了本地线程分配缓冲，按线程优先在TLAB上分配)，<br> <strong>少数情况下可能会直接分配在养老区</strong>。</p></li> <li><p>永久代 就是方法区的实现。</p> <ul><li><p>JDK7 之前有永久代；</p></li> <li><p>JDK7 有永久代，但逐渐”去永久代“；</p></li> <li><p>JDK8 无永久代，被 元空间 代替。</p></li></ul></li></ul></blockquote></li> <li><p><code>java.lang.OutOfMemoryError</code>：内存溢出。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，会抛出异常。</p> <ul><li><code>java.lang.OutOfMemoryError: Java heap space异常</code>：说明JVM的堆内存不够。
<ul><li>原因：JVM的堆内存设置不够，可以通过参数 -Xms (启动时占用内存大小)、-Xmx (运行期间最大可占用的内存大小)来调整。</li></ul></li> <li><code>java.lang.OutOfMemoryError: PermGen space</code>：说明是 JVM 对永久代Perm内存设置不够。
<ul><li>一般出现这种情况，都是程序启动需要加载大量的第三方jar包。例如：在一个Tomcat下部署太多应用。或者大量动态反射生成的类不断被加载，最终导致Perm区被占满。</li></ul></li></ul></li></ul> <h3 id="堆内存调优"><a href="#堆内存调优" class="header-anchor">#</a> 堆内存调优</h3> <table><thead><tr><th style="text-align:left;">参数</th> <th style="text-align:left;">分配内存说明</th></tr></thead> <tbody><tr><td style="text-align:left;">-Xms</td> <td style="text-align:left;">堆初始内存大小 (默认为物理内存的 1/64)</td></tr> <tr><td style="text-align:left;">-Xmx</td> <td style="text-align:left;">堆最大内存大小 (默认为物理内存的 1/4)</td></tr> <tr><td style="text-align:left;">-Xmn</td> <td style="text-align:left;">堆新生代内存大小</td></tr> <tr><td style="text-align:left;">-Xss</td> <td style="text-align:left;">每个线程堆栈的内存大小(默认JDK5后1M，以前256K)</td></tr> <tr><td style="text-align:left;">-XX:+PrintGCDetails</td> <td style="text-align:left;">输出详细的GC处理日志</td></tr> <tr><td style="text-align:left;">-XX:+HeapDumpOnOutOfMemoryError</td> <td style="text-align:left;">OOM时导出堆到文件</td></tr></tbody></table> <ul><li><p>Java代码获取JVM内存信息：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 返回JVM的内存总量(-Xms)</span>
<span class="token keyword">long</span> totalMemory <span class="token operator">=</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">totalMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 返回JVM试图使用的最大内存(-Xmx)</span>
<span class="token keyword">long</span> maxMemory <span class="token operator">=</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">maxMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>使用JVM参数 ：</p> <p><img src="https://good-person.gitee.io/blog-bed/d5b25522287f439085a51bf338e9a661.png" alt=""></p> <p><img src="https://good-person.gitee.io/blog-bed/6e16c52c83ad464e8eebd49bdfc08c94.png" alt=""></p></li> <li><p><code>-Xms8m -Xmx8m -XX:+PrintGCDetails</code></p> <p><img src="https://good-person.gitee.io/blog-bed/a4b4247f878c4202a7cbeee79b08e272.png" alt=""></p></li> <li><p>JVM内存分析工具(很多，介绍2个)：</p> <ul><li><p><code>jvisualvm.exe</code> ：$JAVA_HOME/bin/jvisualvm.exe</p> <p><img src="https://good-person.gitee.io/blog-bed/cac16192207a4a218bd903e5f2babd6f.png" alt=""></p></li> <li><p><a href="https://www.eclipse.org/mat/" target="_blank" rel="noopener noreferrer">Eclipse MAT<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><img src="https://good-person.gitee.io/blog-bed/4034ad7de5ac491c98a26e7a7d0a3a54.png" alt=""></p></li></ul> <blockquote><p>加上 -XX:+HeapDumpOnOutOfMemoryError，出现OOM错误，就会导出堆信息，生成.hprof文件。</p> <p>注意：<strong>XxxError用Exception是捕捉不到的，因为它是Throwable的子类</strong>。</p></blockquote></li></ul> <h2 id="gc"><a href="#gc" class="header-anchor">#</a> GC</h2> <p><img src="https://good-person.gitee.io/blog-bed/7fd7996b8bfc40858b5758b0d8004d5b.png" alt=""></p> <ul><li>GC：JVM的垃圾回收，采用 <strong>分代收集算法</strong>。<strong>次数上，频繁收集 新生区(Young)，较少收集 养老区(Old)，基本不动 永久区(Perm)</strong>。</li> <li>GC分类：
<ul><li>普通GC (Minor GC)：只针对新生代的GC。</li> <li>全局GC (Major GC / Full GC)：针对老年代的GC，偶尔伴随对新生代的GC以及对永久代的GC。</li></ul></li></ul> <h3 id="gc-4大算法"><a href="#gc-4大算法" class="header-anchor">#</a> GC 4大算法</h3> <ul><li><p><strong>引用计数法</strong>：给内存中的对象给打上标记，对象被引用一次，计数就加1，引用被释放了，计数就减一，当这个计数为0的时候，这个对象就可以被回收了。</p> <p><img src="https://good-person.gitee.io/blog-bed/69b99ac27afa44e2b875ad13dc0d9b0a.png" alt=""></p> <blockquote><p>缺点 (<strong>JVM一般不采用引用计数法</strong>)：</p> <ul><li>对象每次赋值只均要维护引用计数器，且计数器本身也有一定的消耗。</li> <li>较难处理循环引用。</li></ul></blockquote></li> <li><p><strong>复制算法 (Copying)</strong>：<strong>新生代使用的 Minor GC，采用的是 复制算法。</strong><br>
经过一次Minor GC (检查伊甸区和幸存from区)后，如果存活的对象能够被幸存to区容纳(即to区有足够的空间来存储伊甸区和from区中所有存活的对象)，则使用复制算法将这些存活的对象复制到幸存to区，然后清理清理伊甸区和from区，并设置年龄(新对象为1，其它对象加1)。幸存区的2个分区交换身份，空闲的区为幸存to区。以后发生Minor GC，幸存分区也是不停 复制，清理，交换身份。当存活的对象熬到15岁，这些对象就会进入养老区。(一般来说，如果幸存to区能够容纳，伊甸区所有存活的对象都会被复制到幸存to区，而在幸存from区存活的对象会根据年龄值来决定去向。)</p> <p><img src="https://good-person.gitee.io/blog-bed/15115f71ee0740b28a1540fd230d91f6.png" alt=""></p> <p><img src="https://good-person.gitee.io/blog-bed/4bc043f7ea1a4b5da84711e30f985a52.png" alt=""></p> <blockquote><ul><li>复制算法的基本思想：将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。<strong>复制算法不会产生内存碎片</strong>。</li> <li>-XX:MaxTenuringThreshold		设置对象在新生代中存活的次数</li></ul></blockquote></li> <li><p><strong>标记清除 (Mark-Sweep)</strong>：当堆中的有效内存空间被耗尽时，就会停止整个程序(stop the world)，然后进行标记和清除。</p> <ul><li>标记：从引用根节点开始标记所有被引用的对象。标记的过程就是遍历所有的 GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。</li> <li>清除：遍历整个堆，把未标记的对象清除。</li></ul> <p><img src="https://good-person.gitee.io/blog-bed/5fa28e3fc36543c9b5a4f3f6dc0e3447.png" alt=""></p> <blockquote><p>缺点：</p> <ul><li>效率比较低(递归与遍历全推对象)，需要暂停整个应用。</li> <li>会产生内存碎片，因为这种方式清理出来的空闲内存是不连续的。JVM就不得不维持一个内存的空闲列表，这又是一种开销。而且分配数组对象时，寻找连续的内存空间不好找。</li></ul></blockquote></li> <li><p><strong>标记压缩 (Mark-Compact)</strong>：标记过程 与标记清除一样，在整理压缩阶段，不再对标记的对象做回收，而是所有存活对象都向一端移动，然后直接清除边界以外的内存。(这不用维护一个空闲列表)</p> <p><img src="https://good-person.gitee.io/blog-bed/77ef9cf5ed784281bb599e31555ffb21.png" alt=""></p> <blockquote><p>缺点：效率比较，不仅要标记所有存活的对象，还要整理所有存活对象的引用地址。</p></blockquote></li> <li><p><strong>标记清除压缩 (Mark-Sweep-Compact)</strong>：上面是GC的4大算法，标记清除压缩(Mark-Sweep-Compact) 是 标记清除(Mark-Sweep) 和 标记压缩(Mark-Compact) 的结合。<strong>老年代一般是由 标记清除 或 标记清除压缩 的混合实现。</strong></p> <ul><li>原理：和 标记清除 一致，当进行多次GC后才压缩。</li> <li>优势：减少移动对象的成本。</li></ul></li> <li><p>总结：</p> <ul><li><p>内存效率：复制算法 &gt; 标记清除 &gt; 标记压缩  (此处只是简单的对比时间复杂度，实际情况不一定)</p></li> <li><p>内存整齐度：复制算法 = 标记压缩 &gt; 标记清除</p></li> <li><p>内存利用率：标记压缩 = 标记清除 &gt; 复制算法</p></li> <li><p><strong>最合适的算法：分代收集算法</strong></p> <ul><li><p><strong>新生代</strong>：对象存活率低，适合 <strong>复制算法</strong>。</p></li> <li><p><strong>老年代</strong>：大量存活率高的对象，适合 <strong>标记清除 或 标记清除压缩 和混合实现</strong>。</p> <blockquote><ul><li>标记阶段：开销与存活对象数量成正比，对于老年代有些不符。但可以通过多核/多线程利用，用并发、并行的形式提高标记效率。</li> <li>清除阶段：开销与所管理区域的大小成正相关。但清除”就地处决“的特点，回收的过程没有对象的移动。相对于有对象移动的回收算法，仍然时效率最高的，不过内存碎片。</li> <li>压缩阶段：开销与存活对象的数据量成正比，对于大量移动对象是很大开销的，作为老年代的第一选择并不合适。所以老年代一般是标记清除 或 标记清除压缩 和混合实现。</li></ul></blockquote></li></ul></li></ul></li></ul> <h2 id="jmm"><a href="#jmm" class="header-anchor">#</a> JMM</h2> <h2 id="面试"><a href="#面试" class="header-anchor">#</a> 面试</h2> <ul><li>请谈谈你对JVM的理解？Java8的虚拟机有什么更新？</li> <li>什么是OOM？什么是StackOverflowError?有哪些方法分析？</li> <li>JVM的常用参数调优你知道哪些？</li> <li>内存快照抓取和MAT分析DUMP文件知道吗？</li> <li>谈谈JVM中，对类加载器你的认识？</li> <li>JVM内存模型以及分区，需要详细到每个区放什么？</li> <li>堆里面的分区：Eden、Survial from to、Old，各自的特点。</li> <li>GC的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方</li> <li>Minor GC 与 Full GC 分别在什么时候发生。</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.04a292d2.js" defer></script><script src="/assets/js/2.4fad892d.js" defer></script><script src="/assets/js/5.811e20e2.js" defer></script>
  </body>
</html>
